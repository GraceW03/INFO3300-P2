<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <link rel="stylesheet" href="styles/style.css">
</head>


<style>
  .state {
    fill: lightgrey;
  }

  .outline {
    fill: none;
    stroke: black;
    stroke-width: 1px;
  }

  .graticule {
    fill: none;
    stroke: grey;
    stroke-width: 1px;
  }

  .tooltip {
    pointer-events: none;
  }
</style>

<body>

  <!-- Scrolling bar for timeline, TODO -->

  <!-- First SVG section with interactive map + bar charts -->
  <svg id="choropleth" height="500" width="600"></svg>
  <svg id="bar1" height="500" width="400"></svg>
  <svg id="bar2" height="500" width="400"></svg>

  <input type="range" id="slider-value" name="slider-value" value="0" min="0" max="100" step="1"
    style="width: 600px; margin-top: 10px;" />
  <label for="slider-value" id="date">Date: </label>

  <script>
    const requestData = async function () {
      const svg = d3.select("#choropleth");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;

      /*************************** Create the map **************************/
      const us = await d3.json("./data/us-smaller.json"); // what's up with the period??? ask TA
      var states = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);
      console.log(states);
      console.log(statesMesh);

      const map = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


      /********** CODE FROM NOTES IDK WHAT IS GOING ON ***************/
      // draws the projection lines for the globe (can remove later)
      // let graticule = d3.geoGraticule10();
      // console.log(graticule);
      // map.append("path").attr("class", "graticule").attr("d", path(graticule));


      // 2c. Draw states and outlines (see CSS at the top)
      let statePaths = map.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)  // debugging
        .attr("d", path)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState); // TODO

      map.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      /********** END NOTES ***************/


      /********** Upload data for map ***************/
      const vaccineData = await d3.csv("./data/us_state_vaccinations.csv", d3.autoType);

      // aggregate data by state, get total and add it
      var stateDict = {}   // stateID ===> stateData
      vaccineData.forEach(d => {
        if (stateDict[d.location]) {
          stateDict[d.location] += d.total_vaccinations;
        } else {
          stateDict[d.location] = d.total_vaccinations
        };
      });

      const minMax = d3.extent(Object.values(stateDict));
      console.log(minMax);

      // const colors = d3.scaleSequential(d3.interpolateBlues);

      // const colorScale = d3.scaleQuantile()
      //   .domain(minMax)
      //   .range(colors);

      const colorScale = d3.scaleQuantile()
        .domain(Object.values(stateDict))
        .range(["#ddd", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"]);

      console.log(stateDict);


      const stateCodes = await d3.csv("./data/state_codes.csv", d3.autoType);
      var codeDict = {}
      stateCodes.forEach(d => {
        codeDict[d.state_code] = d.state_name;
      });


      map.selectAll(".state")
        .style("fill", d => {
          return colorScale(stateDict[codeDict[d.id]]);
        });

      //hover and add box for a more detailed view into the data

      let tooltipWidth = 120;
      let tooltipHeight = 40;

      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");

      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");
      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2)
        .attr("font-size", "10px");
      let txt2 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 22)
        .attr("font-size", "10px");

      function mouseEntersState() {
        tooltip.style("visibility", "visible")

        //let stateID = state.datum().id;
        // let stateDat = stateDict[stateID]
        //let totalVaccinations = stateDict[stateID];
        let state = d3.select(this);
        let stateID = state.datum().id;
        let stateName = codeDict[stateID];
        let totalVaccinations = stateDict[stateName];

        // txt.text(stateDat.state_name);
        // txt2.text(stateDat.total);
        txt.text(stateName);  // Display state ID as state name
        txt2.text(totalVaccinations ? `Total: ${totalVaccinations}` : "Data unavailable");


        let bounds = path.bounds(state.datum());
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1] - 15;

        tooltip.attr("transform", `translate(${xPos},${yPos})`);

        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });
        momesh.datum(mo).attr("d", path)

      }

      function mouseLeavesState() {
        tooltip.style("visibility", "hidden");

        let state = d3.select(this);
        momesh.attr("d", "");
      }

      /****************** Panning and Zooming on Map *******************/
      var zoom = d3.zoom()
        .scaleExtent([1, 20])
        .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])
        .on("zoom", mapZoomed);

      svg.call(zoom);

      svg.call(zoom.transform, d3.zoomIdentity);


      // This time we're using *destructuring assignments* to directly get the values we need
      // Check out these docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
      function mapZoomed({ transform }) {
        map.attr("transform", transform.toString());

        map.select(".state-outline")
          .style("stroke-width", 2 / transform.k);
        map.select(".county-outline")
          .style("stroke-width", 1 / transform.k);

        // Expose county layer when sufficiently zoomed
        // viewport.select(".county-outline")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
        // viewport.selectAll(".county")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");

      }


      // BONUS: Click on a state/county to zoom in on it!
      map.selectAll(".state").on("click", clicked);
      // viewport.selectAll(".county").on("click", clicked);

      function clicked(event, d) {
        console.log(d)

        // geoPath generators have a few extra functions. .bounds returns a pixel rectangle bounding the shape you give it
        let bounds = path.bounds(d.geometry); // get bounds for clicked state/county
        let dx = bounds[1][0] - bounds[0][0]; // width of state/county
        let dy = bounds[1][1] - bounds[0][1]; // height of state/county
        let x = (bounds[0][0] + bounds[1][0]) / 2; // center x of state/county
        let y = (bounds[0][1] + bounds[1][1]) / 2; // center y of state/county

        // We want to make sure scale is within 1-10 when we click, so things don't zoom too far or too little
        // To compute zoom, we want to make sure the bounding box "just" fits onscreen.
        // dx / mapWidth gets us the portion of the screen the shape takes up without any zoom at all
        //  the lower dx/mapWidth is, the more we need to zoom because the shape is smaller
        // We find the max of dx/mapWidth, dy/mapHeight because we don't want to zoom farther (smaller values need more zoom)
        // We do 1 or 0.9 divided by dx/mapWidth because we need larger numbers to zoom in. 0.9 allows us to pad things a bit
        let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dx / mapWidth,
          dy / mapHeight)));

        // Think of the translate like a delta describing how much we need to move the map to move a point to a desired position
        // Simplistically, it works like (desired position) - (current position) = (translation)
        // In this case mapWidth/2, the center of the screen is the desired place for our viewport
        // x*scale is the position we want to move to the center (scale is there because we need to move more when zoomed in)
        let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];

        // It's hard to programmatically adjust a zoom. The best way is to take the Identity (zoom transform where nothing is changed)
        //  and then modify it using a .translate and .scale
        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);
        // We can apply a new transform to the screen by using .call(zoom.tranform, newTransform)
        // This is kinda the same thing as running zoom.transform(newTransform), but the chaining with .call allows us to add an animation
        svg.transition().duration(1000).call(zoom.transform, newTransform);

      }
    }
    requestData();

  </script>

  <!-- Line graph -->

</body>

</html>