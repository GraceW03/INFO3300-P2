<html>


<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <link rel="stylesheet" href="styles/style.css">
</head>


<!-- put any CSS in styles/style.css -->


<body>


  <h3>COVID-19 Vaccinations across the US from 2021-2023</h3>


  <div class="navbar">
    <button onclick="update(2021)">2021</button>
    <button onclick="update(2022)">2022</button>
    <button onclick="update(2023)">2023</button>
    <button onclick="update('total')">Total</button>
  </div>


  <div>
    <button onclick="variableChange('total_vaccinations')">Total Vaccinations</button>
    <button onclick="variableChange('people_fully_vaccinated')">People Fully Vaccinated</button>
    <button onclick="variableChange('total_boosters')">Boosters</button>
  </div>


  <!-- First SVG section with interactive map + bar charts -->
  <svg id="choropleth" height="500" width="600"></svg>


  <br>


  <!-- line graph -->
  <h3>New People Fully Vaccinated Over Time, by State</h3>
  <label for="stateSelector">Select State:</label>
  <select id="stateSelector"></select>
  <svg id="lineplot" height="500" width="800" style="margin-top:50px">
  </svg>


  <br>


  <!-- manufacturer bar graph -->
  <svg id="barchart" height="500" width="600"></svg>

  <svg id="legend3" height="200" width="150"></svg>


  <script>


    const requestData = async function () {

      const svg = d3.select("#choropleth");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;


      /*************************** Create the map **************************/
      // referenced October 9 lecture
      const us = await d3.json("./data/us-smaller.json"); // what's up with the period??? ask TA
      var states = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);
      console.log(states);
      console.log(statesMesh);


      const map = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


      // draw states and outlines (see CSS at the top)
      let statePaths = map.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState);


      map.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);




      /********** Upload data for map ***************/
      const vaccineData = await d3.csv("./data/us_state_vaccinations.csv", d3.autoType);
      const stateCodes = await d3.csv("./data/state_codes.csv", d3.autoType);


      // aggregate data by state, get total and add it
      var stateDict = {}   // stateID ===> stateData
      var codeDict = {}
      stateCodes.forEach(d => {
        codeDict[d.state_code] = d.state_name;
      });


      let currentYear = "total";
      let currentVariable = 'total_vaccinations';
      function variableChange(variable) {
        currentVariable = variable;
        update(currentYear);
      }


      function addYears(year) {
        stateDict = {};
        vaccineData.forEach(d => {
          const dataYear = new Date(d.date).getFullYear();
          if (year === 'total' || dataYear === year) {
            stateDict[d.location] = (stateDict[d.location] || 0) + d[currentVariable];
          }
        });
      }

      function update(year) {
        addYears(year);
        currentYear = year;
        const colorScale = d3.scaleQuantile()
          .domain(Object.values(stateDict))
          .range(["#ddd", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"]);


        svg.selectAll(".state")
          .style("fill", d => colorScale(stateDict[codeDict[d.id]]));
      }


      //hover and add box for a more detailed view into the data


      var tooltipWidth = 120;
      var tooltipHeight = 40;


      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "black")
        .style("stroke-width", 3)
        .attr("d", "");


      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");
      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2)
        .attr("font-size", "10px");
      let txt2 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 22)
        .attr("font-size", "10px");


      function mouseEntersState() {
        tooltip.style("visibility", "visible")


        let state = d3.select(this);
        let stateID = state.datum().id;
        let stateName = codeDict[stateID];
        let totalVaccinations = stateDict[stateName];


        txt.text(stateName);
        txt2.text(totalVaccinations ? `Total: ${totalVaccinations}` : "Data unavailable");




        let xPos = mapWidth - margin.right - 10;
        let yPos = margin.top + 10;

        tooltip.attr("transform", `translate(${xPos},${yPos})`);



        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });
        momesh.datum(mo).attr("d", path)


      }


      function mouseLeavesState() {
        tooltip.style("visibility", "hidden");


        let state = d3.select(this);
        momesh.attr("d", "");
      }


      /****************** Panning and Zooming on Map *******************/
      var zoom = d3.zoom()
        .scaleExtent([1, 20])
        .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])
        .on("zoom", mapZoomed);


      svg.call(zoom);


      svg.call(zoom.transform, d3.zoomIdentity);


      // referenced zooming and panning lecture
      function mapZoomed({ transform }) {
        map.attr("transform", transform.toString());


        map.select(".state-outline")
          .style("stroke-width", 2 / transform.k);
      }




      // Click on a state/county to zoom in on it, and again to zoom out
      map.selectAll(".state").on("click", clicked);


      var stateClicked = false;


      function clicked(event, d) { // zoom out
        console.log(d)
        if (stateClicked) {
          let translate = [margin.left, margin.right];


          let newTransform = d3.zoomIdentity
            .translate(translate[0], translate[1])
            .scale(1);
          svg.transition().duration(1000).call(zoom.transform, newTransform);


          stateClicked = false;
        }


        else { // zoom out
          // geoPath generators have a few extra functions. .bounds returns a pixel rectangle bounding the shape you give it
          let bounds = path.bounds(d.geometry);
          let dx = bounds[1][0] - bounds[0][0];
          let dy = bounds[1][1] - bounds[0][1];
          let x = (bounds[0][0] + bounds[1][0]) / 2;
          let y = (bounds[0][1] + bounds[1][1]) / 2;


          let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dx / mapWidth,
            dy / mapHeight)));


          let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];


          let newTransform = d3.zoomIdentity
            .translate(translate[0], translate[1])
            .scale(scale);
          svg.transition().duration(1000).call(zoom.transform, newTransform);


          stateClicked = true;
        }
      }
      window.variableChange = variableChange;

      update(currentYear);

      window.update = update;
    }
    requestData();


    /************************* Bar graph code *************************/
    const bargraph = async function () {
      const svg = d3.select("svg#barchart");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 10, right: 10, bottom: 70, left: 100 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;


      let annotations = svg.append("g").attr("id", "annotations");
      let chartArea = svg.append("g").attr("id", "bars")
        .attr("transform", `translate(${margin.left},${margin.top})`);




      d3.csv("./data/us_vaccine_manufacturer_data.csv", d3.autoType)
        .then((data) => {


          const timeFormatter = d3.timeFormat('%Y-%m');


          data.forEach(d => {
            d['month'] = timeFormatter(d['date']);
          });


          let monthDict = {}; // {month: {vaccine: total_vaccinations}}
          data.forEach(d => {
            if (!monthDict[d.month]) monthDict[d.month] = {};
            if (!monthDict[d.month][d.vaccine]) monthDict[d.month][d.vaccine] = 0;
            monthDict[d.month][d.vaccine] += d.total_vaccinations;
          });


          let flatData = [];
          for (let month in monthDict) {
            let row = { month: month };
            for (let vaccine in monthDict[month]) {
              row[vaccine] = monthDict[month][vaccine];
            }
            flatData.push(row);
          }


          const manufacturers = Array.from(new Set(data.map(d => d.vaccine)));


          flatData.forEach(row => {
            manufacturers.forEach(manufacturer => {
              if (!row[manufacturer]) {
                row[manufacturer] = 0;
              }
            });
          });


          console.log("data for bar graph");
          console.log(flatData);


          const allMonths = flatData.map(d => d.month).sort();


          const xScale = d3.scaleBand()
            .domain(allMonths)
            .range([0, chartWidth])
            .padding(0.1);


          const xSubgroupScale = d3.scaleBand()
            .domain(manufacturers)
            .range([0, xScale.bandwidth()])
            .padding(0.05);


          // referenced https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap
          const manufacturerArray = flatData.flatMap(month => [
            month['Moderna'],
            month['Pfizer/BioNTech'],
            month['Johnson&Johnson']
          ]);


          const yExtent = d3.extent(manufacturerArray);


          const yScale = d3.scaleLinear()
            .domain([0, yExtent[1]])
            .range([chartHeight, 0]);


          const colorScale = d3.scaleOrdinal()
            .domain(manufacturers)
            .range(d3.schemeCategory10);


          // Add axes
          let leftAxis = d3.axisLeft(yScale);
          annotations.append("g")
            .attr("class", "y axis")
            .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
            .call(leftAxis);


          // referenced http://www.d3noob.org/2013/01/how-to-rotate-text-labels-for-x-axis-of.html
          // for help rotating axis text
          let bottomAxis = d3.axisBottom(xScale);
          annotations.append("g")
            .attr("class", "x axis")
            .attr("transform", `translate(${margin.left}, ${chartHeight + margin.top + 10})`)
            .call(bottomAxis)
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-10")
            .attr("dy", "2")
            .attr("transform", "rotate(-65)");


          chartArea.append("g")
            .selectAll("g")
            // Enter in the data = loop through each month
            .data(flatData)
            .enter()
            .append("g")
            .attr("transform", function (d) { return "translate(" + xScale(d.month) + ",0)"; })
            .selectAll("rect")
            .data(function (d) {
              return manufacturers.map(function (key) { return { key: key, value: d[key] || 0 }; });
            })
            .enter().append("rect")
            .attr("x", function (d) { return xSubgroupScale(d.key); })
            .attr("y", function (d) { return yScale(d.value); })
            .attr("width", xSubgroupScale.bandwidth())
            .attr("height", function (d) { return chartHeight - yScale(d.value); })
            .attr("fill", function (d) { return colorScale(d.key); });

          //legend code
          let legend = d3.select("svg#legend3");

          manufacturers.forEach((manufacturer, i) => {
            legend.append("circle")
              .attr("cx", 10)
              .attr("cy", i * 25)
              .attr("r", 7)
              .style("fill", colorScale(manufacturer));

            legend.append("text")
              .attr("x", 30)
              .attr("y", i * 25)
              .text(manufacturer)
              .attr("text-anchor", "left")
              .style("alignment-baseline", "middle");
          });


        });

    }

    bargraph();


    /************************* Line graph code **********************/
    const svg = d3.select("svg#lineplot");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 100, left: 100 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;


    let annotations = svg.append("g").attr("id", "annotations");
    let chartArea = svg.append("g").attr("id", "points")
      .attr("transform", `translate(${margin.left},${margin.top})`);


    // Import some CSV data
    d3.csv("./data/us_state_vaccinations.csv", d3.autoType)
      .then((data) => {


        const timeFormatter = d3.timeFormat('%Y-%m');


        data.forEach(d => {
          d['month'] = timeFormatter(d['date']);
        });


        const notWanted = ["United States", "Guam", 'Bureau of Prisons',
          'Dept of Defense', 'Federated States of Micronesia', 'Indian Health Svc',
          'Long Term Care', 'Marshall Islands', 'Northern Mariana Island',
          'Republic of Palau', 'Veterans Health', 'Puerto Rico'
        ];
        let stateDict = {};
        data.forEach(d => {
          if (!notWanted.includes(d['location'])) {
            if (!stateDict[d['location']]) {
              stateDict[d['location']] = [];
            }
            if (d.people_fully_vaccinated != null) {
              stateDict[d['location']].push({ month: d['month'], people_fully_vaccinated: d['people_fully_vaccinated'] });
            }
          }
        });


        // referenced https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object
        const flatData = Object.keys(stateDict).map(state => ({
          state,
          values: stateDict[state].filter(d => d.people_fully_vaccinated != null)
        }));


        // aggregate flat data together by month
        flatData.forEach(state => {
          let arr = state.values;

          const monthData = {};
          arr.forEach(n => {
            if (!monthData[n.month]) {
              monthData[n.month] = { month: n.month, people_fully_vaccinated: n.people_fully_vaccinated };
            }
            else
              monthData[n.month].people_fully_vaccinated += n.people_fully_vaccinated;
          });
          // {"01-2020": {month: "01-2020", ppl: 10000},
          //  "02-2020": {month: "02-2020", ppl: 10000}}
          state.values = Object.values(monthData);
        });


        // referenced https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap
        const vaccinations = flatData.flatMap(stateData =>
          stateData.values.map(month => month.people_fully_vaccinated)
        );


        const allMonths = Array.from(new Set(data.map(d => d.month))).sort(); // this is not working apparently
        const yExtent = d3.extent(vaccinations);
        console.log(yExtent);
        // const yExtent = d3.extent(data, d => d.people_fully_vaccinated);
        const xScale = d3.scalePoint().domain(allMonths).range([0, chartWidth]);
        const yScale = d3.scaleLinear().domain(yExtent).range([chartHeight, 0]);


        // Add axes
        let leftAxis = d3.axisLeft(yScale);
        annotations.append("g")
          .attr("class", "y axis")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(leftAxis);


        // referenced http://www.d3noob.org/2013/01/how-to-rotate-text-labels-for-x-axis-of.html
        // for help rotating axis text
        let bottomAxis = d3.axisBottom(xScale);
        annotations.append("g")
          .attr("class", "x axis")
          .attr("transform", `translate(${margin.left}, ${chartHeight + margin.top + 10})`)
          .call(bottomAxis)
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-10")
          .attr("dy", "2")
          .attr("transform", "rotate(-65)");


        // // Create line generator
        const lineGen = d3.line()
          .x(d => xScale(d.month))
          .y(d => yScale(d.people_fully_vaccinated))
          //          .defined(d => !isNaN(d.distributed_per_hundred)) // Skip NaN values //chat
          .curve(d3.curveMonotoneX);

        const stateSelector = d3.select("#stateSelector");
        stateSelector.selectAll("option")
          .data(["All States"].concat(Object.keys(stateDict)))
          .enter()
          .append("option")
          .attr("value", d => d)
          .text(d => d);


        // Function to update chart based on selected state
        function updateChart(selectedState) {
          chartArea.selectAll(".line").remove();

          const filteredData = selectedState === "All States"
            ? flatData
            : flatData.filter(d => d.state === selectedState);


          let tooltip = chartArea.append("g")
            .attr("class", "line-tooltip")
            .attr("transform", `translate(${chartWidth - 150}, 20)`) // Fixed to the top-right corner
            .style("visibility", "hidden");


          // Add text for the state name
          let stateLabel = tooltip.append("text");

          filteredData.forEach(stateData => {
            chartArea.append("path")
              .datum(stateData.values)
              .attr("class", "line")
              .attr("d", lineGen)
              .attr("stroke", d3.schemeCategory10[Object.keys(stateDict).indexOf(stateData.state) % 10])
              .attr("stroke-width", 2)
              .attr("fill", "none")
              .on("mouseover", function () {
                d3.select(this)
                  .attr("stroke-width", 4); // Bolden the line

                // Update and show the tooltip
                stateLabel.text(stateData.state) // Set the state name
                  .style("font-size", "20px"); // Enlarge the font
                tooltip.style("visibility", "visible");
              })
              .on("mouseout", function () {
                d3.select(this)
                  .attr("stroke-width", 2); // Reset line width

                // Hide the tooltip
                tooltip.style("visibility", "hidden");
              })
              .append("title") // Tooltip for accessibility
              .text(stateData.state);
          });

        }


        // Initial render with all states
        updateChart("All States");


        // Add event listener for dropdown menu
        stateSelector.on("change", function () {
          const selectedState = d3.select(this).property("value");
          updateChart(selectedState);
        });
      });
  </script>
</body>


</html>